# 					实验指导

原页面位于[Lab Guidance](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html)

## 1. 作业的难度

每个实验里的作业都有它的难度等级表明它的难易程度：

+ Easy ： 不到一个小时。 这些练习通常是后续练习的热身练习。
+ Moderate ：1-2个小时。
+ Hard ： 超过两个小时。通常这些练习不需要太多代码，但是很难书写正确。

这些时间是我们预期的粗略估计。 对于某些可选作业，我们没有解决方案，而且难度也只能靠猜测。

一般来说，练习不需要很多行代码（几十到几百行），但代码在概念上很复杂，而且往往细节很重要。因此，在编写任何代码之前，请确保完成实验室指定的阅读，通读相关文件，查阅文档（RISC-V 手册等，他们位于[参考页](https://pdos.csail.mit.edu/6.828/2020/reference.html)上）。

确保当你牢牢掌握了作业和解决方案后，才开始编码。 当你开始编码时，分小步实施你的解决方案（作业通常会建议你如何将问题分解为更小的步骤），并在继续下一个步骤之前测试每个步骤是否有效。

> 警告：不要在实验截止日期前一天晚上开始实验； 在几天内分几次进行实验会更节省时间。 操作系统内核中错误的表现可能令人困惑，可能需要大量思考和仔细调试才能理解和修复。

---

## 2.调试的技巧

+ 确保你理解c和指针。

+ 如果您的练习部分有效，请通过在**git**上提交代码来检查进度。

+ 如果测试失败，请确保您了解代码未通过测试的原因。 **插入打印语句**，直到您了解发生了什么。

+ 您可能会发现您的 print 语句可能会产生很多您想要搜索的输出； 一种方法是在`script`内运行 `make qemu `，它将所有控制台输出记录到一个文件中，然后您可以搜索该文件。 不要忘记退出`script`。

+ 在许多情况下，打印语句就足够了，但有时能够单步执行某些汇编代码或检查堆栈上的变量会很有帮助。 要将 gdb 与 xv6 一起使用，请在一个窗口中运行` make qemu-gdb`，在另一个窗口中运行 `gdb`（或 riscv64-linux-gnu-gdb），设置一个断点，然后执行“c”（继续）和 操作xv6 ，直到到达断点。:kissing:

+ 如果您想**查看编译器为内核生成的汇编代码是什么，或者想了解特定内核地址处的指令**是什么，请查看文件 kernal/kernel.asm，该文件是 Makefile 在编译内核时生成的。 （Makefile 还为所有用户程序生成 .asm

+ 如果内核发生崩溃，它将打印一条错误消息，列出崩溃时程序计数器的值；你可以搜索**kernal/kernel.asm**来找出内核崩溃时程序计数器在哪个函数中或者你也可以运行`addr2line -e kernel/kernel pc-value`来达到同样的效果。

+ 如果您的内核挂起（例如，由于死锁）或无法进一步执行（例如，由于执行内核指令时出现page fault），您可以使用 gdb 找出它在何处挂起。当内核出现挂起时，在 `qemu-gdb` 窗口中按 Ctrl-C 并在gdb中输入“bt”以回溯。

+ qemu 有一个“监视器”，可以让您查询模拟机器的状态。您可以通过输入 control-a c （“c”代表控制台）来获取它。一个特别有用的监视命令是 **`info mem`**，用于**打印页表**。

  您可能需要使用 cpu 命令来选择要查看哪个核心的 `info mem`，或者您可以使用 `make CPUS=1 qemu` 来启动 qemu，这样只有一个核心。

---

## 3. 其他

+ xv6没有`ps`命令，但是你可以使用`ctrl-p`命令，内核会打印出所有进程的信息。在一开始，只有两个进程：

  init和sh。

+ 退出qemu，按下：`ctrl-a + x`.

---

## 4. 评估和提交程序

+ `make grade` : 

  该命令用来使用评估程序来测试你的解决方案。

  请注意，`make grade` 会运行**所有**测试。 如果您想运行一项作业的成绩测试，请输入：`make GRADEFLAGS=作业名称 grade` 或者 `./grade-lab-util 作业名称`。

  

+ ` gmake handin`：

  将最终更改提交到实验室后，输入该命令以提交您的lab。

  实验代码附带 **GNU Make 规则**，使提交更容易。 

  

---

## 5.关于源码

+ 用户程序可用的库函数。 

  您可以在 **user/user.h** 中看到该列表； 源代码（系统调用除外）位于 **user/ulib.c**、**user/printf.c** 和 **user/umalloc.c** 中。

+ **kernel/sysproc.c**：一些系统调用的xv6内核代码（sys_xxx）。

+ **user/usys.S** ： 从用户代码跳转到内核进行系统调用的汇编代码。使用系统调用号（函数数组的下标）索引。

+ 

